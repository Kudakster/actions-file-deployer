name: "FTP/SFTP file deployer"
description: "Advanced deployment with override support and flexible path mapping"

branding:
  icon: "upload"  
  color: "black"

inputs:
  remote-protocol:
    description: "Remote file transfer protocol (ftp, sftp)"
    required: true
    default: "sftp"
  remote-host:
    description: "Remote host"
    required: true
  remote-port:
    description: "Remote port"
    required: true
    default: 22
  remote-user:
    description: "FTP/SSH username"
    required: true
  remote-password:
    description: "FTP/SSH password"
    required: false
    default: ""
  ssh-private-key:
    description: "SSH private key of user"
    required: false
  proxy:
    description: "Enable proxy for FTP connection (true, false)"
    required: true
    default: false
  proxy-host:
    description: "Proxy host"
    required: false
  proxy-port:
    description: "Proxy port"
    required: false
    default: 22
  proxy-forwarding-port:
    description: "Proxy forwarding port"
    required: false
    default: 1080
  proxy-user:
    description: "Proxy username"
    required: false
  proxy-private-key:
    description: "Proxy SSH private key of user"
    required: false
  paths:
    description: "Path mappings in JSON format (add :flat suffix to flatten)"
    required: true
    default: '{".": "."}'
  override-path:
    description: "Path to server-specific override folder"
    required: false
    default: ""
  sync:
    description: "File synchronization (delta, full)"
    required: true
    default: "delta"
  sync-delta-excludes:
    description: "Files to exclude from delta sync"
    required: false
  ssh-options:
    description: "Additional command arguments for SSH client"
    required: false
  ftp-options:
    description: "Additional command arguments for FTP client (lftp)"
    required: false
  ftp-mirror-options:
    description: "Additional command arguments for mirroring (lftp)"
    required: false
  ftp-post-sync-commands:
    description: "Additional ftp commands to run after synchronization (lftp)"
    required: false
  webhook:
    description: "Send webhook event notifications"
    required: false
  artifacts:
    description: "Upload logs to artifacts"
    required: false
  debug:
    description: "Enable debug information (true, false)"
    required: false

runs:
  using: "composite"
  steps:
    - name: "Install dependencies"
      shell: bash
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y --no-install-recommends lftp jq
        if [ "${{ inputs.proxy }}" == "true" ]; then
          sudo apt-get install -y --no-install-recommends proxychains
        fi

    - name: "Deploy"
      shell: bash
      run: |
        # Helper functions
        function show_hr() {
          printf '%.s_' {1..100} && echo ""
        }

        function send_webhook() {
          [ -z "${{ inputs.webhook }}" ] && return
          local status="$1"
          local post_data=$(jq --null-input \
            --arg status "$status" \
            --arg repository "${{ github.repository }}" \
            --arg workflow "${{ github.workflow }}" \
            --arg job "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            '{"status": $status, "repository": $repository, "workflow": $workflow, "job": $job, "run_id": $run_id}')
          curl -X POST -H "Content-Type: application/json" -d "$post_data" "${{ inputs.webhook }}"
        }

        # Initialize
        echo "::group::Initialization"
        [ -n "${{ inputs.webhook }}" ] && send_webhook "start"

        # Validate Git repo
        if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != "true" ]; then
          echo "::error::Git repository not found"
          exit 1
        fi

        # Parse path mappings
        declare -A path_mappings
        declare -A flatten_flags
        FLATTEN_KEYWORD=":flat"

        while IFS="=" read -r local_path remote_mapping; do
          if [[ "$remote_mapping" == *"$FLATTEN_KEYWORD"* ]]; then
            remote_path="${remote_mapping%$FLATTEN_KEYWORD}"
            flatten_flags["$local_path"]=1
          else
            remote_path="$remote_mapping"
            flatten_flags["$local_path"]=0
          fi
          
          path_mappings["$(echo "$local_path" | sed 's:/*$::')"]="$(echo "$remote_path" | sed 's:/*$::')"
        done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' <<< "${{ inputs.paths }}")

        # Debug output
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "Path Mappings:"
          for path in "${!path_mappings[@]}"; do
            echo "  $path → ${path_mappings[$path]} $([ ${flatten_flags[$path]} -eq 1 ] && echo "(FLAT)")"
          done
          show_hr
        fi

        # Setup configurations
        echo "::group::Configuration"
        mkdir -p ~/.ssh
        echo -e "StrictHostKeyChecking no\nUserKnownHostsFile /dev/null" > ~/.ssh/config
        chmod 600 ~/.ssh/config

        # Create lftp config
        cat > ~/.lftprc <<'EOF'
        set ftp:ssl-protect-data true
        set net:timeout 10
        set xfer:parallel 3
        set mirror:parallel-transfer-count 3
        set sftp:auto-confirm true
        EOF
        
        echo "::endgroup::"

        # File processing
        echo "::group::Prepare files"
        if [ "${{ inputs.sync }}" == "delta" ]; then
          touch ~/files_to_upload ~/files_to_delete ~/override_changes
          git_previous_commit=""

          # Determine previous commit
          if [ "${{ github.event_name }}" == "push" ]; then
            git_previous_commit=${{ github.event.before }}
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            git_previous_commit=${{ github.event.pull_request.base.sha }}
          else
            git_previous_commit=$(git rev-parse ${{ github.sha }}^)
          fi

          if git cat-file -t "$git_previous_commit" &>/dev/null; then
            # Process override folder if specified
            if [ -n "${{ inputs.override-path }}" ] && [ -d "${{ inputs.override-path }}" ]; then
              git diff --diff-filter=ACMRT --name-only "$git_previous_commit"..${{ github.sha }} -- "${{ inputs.override-path }}" > ~/override_changes
            fi

            # Process each path mapping
            for local_path in "${!path_mappings[@]}"; do
              remote_path="${path_mappings[$local_path]}"
              
              # Get changes from main folder (excluding overrides)
              git diff --diff-filter=ACMRT --name-only "$git_previous_commit"..${{ github.sha }} -- "$local_path" > ~/main_changes.tmp
              
              # Filter out overrides
              if [ -s ~/override_changes ]; then
                grep -vFf <(sed "s|^${{ inputs.override-path }}/||" ~/override_changes) ~/main_changes.tmp > ~/filtered_changes.tmp
              else
                cp ~/main_changes.tmp ~/filtered_changes.tmp
              fi

              # Convert to mapping format
              awk -v local="$local_path" -v remote="$remote_path" '
                {
                  gsub("^" local "/?", "")
                  if ($0 != "") {
                    print local "|" $0 " -> " remote "/" $0
                  }
                }' ~/filtered_changes.tmp >> ~/files_to_upload

              # Process deletions
              git diff-tree --diff-filter=D --name-only -t "$git_previous_commit"..${{ github.sha }} -- "$local_path" > ~/deletions.tmp
              awk -v remote="$remote_path" '{print remote "/" $0}' ~/deletions.tmp >> ~/files_to_delete

              rm -f ~/main_changes.tmp ~/filtered_changes.tmp ~/deletions.tmp
            done

            # Add override changes
            if [ -s ~/override_changes ]; then
              while read -r override_file; do
                rel_path="${override_file#${{ inputs.override-path }}/}"
                for local_path in "${!path_mappings[@]}"; do
                  if [[ "$rel_path" == "$local_path"* ]]; then
                    remote_path="${path_mappings[$local_path]}"
                    echo "${{ inputs.override-path }}|$rel_path -> $remote_path/${rel_path#$local_path/}" >> ~/files_to_upload
                    break
                  fi
                done
              done < ~/override_changes
            fi
          fi
        fi

        # Debug output
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "::group::File Changes"
          echo "Files to upload:"
          [ -s ~/files_to_upload ] && cat ~/files_to_upload || echo "None"
          show_hr
          echo "Files to delete:"
          [ -s ~/files_to_delete ] && cat ~/files_to_delete || echo "None"
          show_hr
          echo "Override changes:"
          [ -s ~/override_changes ] && cat ~/override_changes || echo "None"
          echo "::endgroup::"
        fi
        echo "::endgroup::"

        # File transfer
        echo "::group::Transfer files"
        function process_upload() {
          local src="$1"
          local dest="$2"
          local flatten="$3"

          if [ "$flatten" -eq 1 ]; then
            # FLAT MODE - upload directly to destination folder without subfolders
            remote_file="$(basename "$src")"
            echo "FLAT UPLOAD: $src → $dest/$remote_file"
            ${proxy_cmd} lftp -u "${{ inputs.remote-user }}","${{ inputs.remote-password }}" -p "${{ inputs.remote-port }}" \
              -e "mkdir -p \"$dest\"; put -O \"$dest\" \"$src\" -o \"$remote_file\"; quit" \
              "${{ inputs.remote-protocol }}://${{ inputs.remote-host }}"
          else
            # NORMAL MODE - preserve folder structure
            relative_path="${src#$local_path/}"
            echo "NORMAL UPLOAD: $src → $dest/$relative_path"
            ${proxy_cmd} lftp -u "${{ inputs.remote-user }}","${{ inputs.remote-password }}" -p "${{ inputs.remote-port }}" \
              -e "mkdir -p \"$dest/$(dirname "$relative_path")\"; put -O \"$dest/$(dirname "$relative_path")\" \"$src\" -o \"$(basename "$relative_path")\"; quit" \
              "${{ inputs.remote-protocol }}://${{ inputs.remote-host }}"
          fi
        }

        # Set proxy command if needed - FIXED INDENTATION
        if [ "false" == "true" ]; then
          proxy_cmd="proxychains -q"
          if [ -n "" ]; then
            # Create custom proxychains config
            cat > /tmp/proxychains.conf <<'EOF'
        strict_chain
        proxy_dns
        [ProxyList]
        sftp  22  
        EOF
            proxy_cmd="$proxy_cmd -f /tmp/proxychains.conf"
          fi
        else
          proxy_cmd=""
        fi

        # Process uploads
        if [ -s ~/files_to_upload ]; then
          while read -r line; do
            src_mapping=$(echo "$line" | awk -F' -> ' '{print $1}')
            dest_path=$(echo "$line" | awk -F' -> ' '{print $2}')
            
            src_path=$(echo "$src_mapping" | cut -d'|' -f1)
            relative_path=$(echo "$src_mapping" | cut -d'|' -f2)

            # Find matching mapping
            for local_path in "${!path_mappings[@]}"; do
              if [[ "$src_path/$relative_path" == "$local_path"* ]]; then
                process_upload "$src_path/$relative_path" "${path_mappings[$local_path]}" "${flatten_flags[$local_path]}"
                break
              fi
            done
          done < ~/files_to_upload
        else
          echo "No files to upload"
        fi

        # Process deletions
        if [ -s ~/files_to_delete ]; then
          echo "Deleting files:"
          ${proxy_cmd} lftp -u "${{ inputs.remote-user }}","${{ inputs.remote-password }}" -p "${{ inputs.remote-port }}" -e "rm -f $(awk '{printf "\"%s\" ", $0}' ~/files_to_delete); ${{ inputs.ftp-post-sync-commands }}; quit" "${{ inputs.remote-protocol }}://${{ inputs.remote-host }}"
        else
          echo "No files to delete"
        fi
        echo "::endgroup::"

        # Cleanup
        echo "::group::Cleanup"
        [ "${{ inputs.proxy }}" == "true" ] && pkill ssh || true
        rm -f ~/.netrc ~/ssh_private_key ~/proxy_private_key
        [ -n "${{ inputs.webhook }}" ] && send_webhook "complete"
        echo "::endgroup::"

    - name: "Upload artifacts"
      if: ${{ inputs.artifacts == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: "deployment-logs"
        path: |
          ~/files_to_upload
          ~/files_to_delete
          ~/transfer_log.txt
        if-no-files-found: ignore
