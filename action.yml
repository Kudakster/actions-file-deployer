name: "FTP/SFTP file deployer"
description: "Advanced deployment with override support and flexible path mapping"

branding:
  icon: "upload"  
  color: "black"

inputs:
  remote-protocol:
    description: "Remote file transfer protocol (ftp, sftp)"
    required: true
    default: "sftp"
  remote-host:
    description: "Remote host"
    required: true
  remote-port:
    description: "Remote port"
    required: true
    default: 22
  remote-user:
    description: "FTP/SSH username"
    required: true
  remote-password:
    description: "FTP/SSH password"
    required: false
    default: ""
  paths:
    description: "Path mappings in JSON format (add :flat suffix to flatten)"
    required: true
    default: '{".": "."}'
  override-path:
    description: "Path to server-specific override folder"
    required: false
    default: ""
  sync:
    description: "File synchronization (delta, full)"
    required: true
    default: "delta"
  sync-delta-excludes:
    description: "Files to exclude from delta sync"
    required: false
  debug:
    description: "Enable debug information (true, false)"
    required: false

runs:
  using: "composite"
  steps:
    - name: "Install dependencies"
      shell: bash
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y --no-install-recommends lftp jq

    - name: "Deploy"
      shell: bash
      run: |
        # Helper functions
        function show_hr() {
          printf '%.s_' {1..100} && echo ""
        }

        # Initialize
        echo "::group::Initialization"

        # Validate Git repo
        if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != "true" ]; then
          echo "::error::Git repository not found"
          exit 1
        fi

        # Parse path mappings
        declare -A path_mappings
        declare -A flatten_flags
        FLATTEN_KEYWORD=":flat"

        while IFS="=" read -r local_path remote_mapping; do
          if [[ "$remote_mapping" == *"$FLATTEN_KEYWORD"* ]]; then
            remote_path="${remote_mapping%$FLATTEN_KEYWORD}"
            flatten_flags["$local_path"]=1
          else
            remote_path="$remote_mapping"
            flatten_flags["$local_path"]=0
          fi
          path_mappings["$(echo "$local_path" | sed 's:/*$::')"]="$(echo "$remote_path" | sed 's:/*$::')"
        done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' <<< "${{ inputs.paths }}")

        # Debug output
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "Path Mappings:"
          for path in "${!path_mappings[@]}"; do
            echo "  $path → ${path_mappings[$path]} $([ ${flatten_flags[$path]} -eq 1 ] && echo "(FLAT)")"
          done
          show_hr
        fi

        # Setup configurations
        echo "::group::Configuration"
        mkdir -p ~/.ssh
        echo -e "StrictHostKeyChecking no\nUserKnownHostsFile /dev/null" > ~/.ssh/config
        chmod 600 ~/.ssh/config

        # Create lftp config
        cat > ~/.lftprc << 'EOF'
        set ftp:ssl-protect-data true
        set net:timeout 10
        set xfer:parallel 3
        set mirror:parallel-transfer-count 3
        $([ "${{ inputs.remote-protocol }}" == "sftp" ] && echo "set sftp:auto-confirm true")
        EOF
        echo "::endgroup::"

        # File processing
        echo "::group::Prepare files"
        if [ "${{ inputs.sync }}" == "delta" ]; then
          touch ~/files_to_upload ~/files_to_delete ~/override_changes
          git_previous_commit=$(git rev-parse ${{ github.sha }}^)

          if git cat-file -t "$git_previous_commit" &>/dev/null; then
            # Process override folder if specified
            if [ -n "${{ inputs.override-path }}" ] && [ -d "${{ inputs.override-path }}" ]; then
              git diff --diff-filter=ACMRT --name-only "$git_previous_commit"..${{ github.sha }} -- "${{ inputs.override-path }}" > ~/override_changes
            fi

            # Process each path mapping
            for local_path in "${!path_mappings[@]}"; do
              remote_path="${path_mappings[$local_path]}"
              
              # Get changes from main folder (excluding overrides)
              git diff --diff-filter=ACMRT --name-only "$git_previous_commit"..${{ github.sha }} -- "$local_path" > ~/main_changes.tmp
              
              # Filter out overrides if they exist
              if [ -s ~/override_changes ]; then
                grep -vFf <(sed "s|^${{ inputs.override-path }}/||" ~/override_changes) ~/main_changes.tmp > ~/filtered_changes.tmp
              else
                cp ~/main_changes.tmp ~/filtered_changes.tmp
              fi

              # Apply sync-delta-excludes if specified
              if [ -n "${{ inputs.sync-delta-excludes }}" ]; then
                grep -vFf <(echo "${{ inputs.sync-delta-excludes }}" | tr ',' '\n') ~/filtered_changes.tmp > ~/filtered_changes2.tmp
                mv ~/filtered_changes2.tmp ~/filtered_changes.tmp
              fi

              # Convert to mapping format with proper flat handling
              awk -v local="$local_path" -v remote="$remote_path" -v flat="${flatten_flags[$local_path]}" '
                {
                  gsub("^" local "/?", "")
                  if ($0 != "") {
                    if (flat == 1) {
                      split($0, parts, "/")
                      print local "|" $0 " -> " remote "/" parts[length(parts)]
                    } else {
                      print local "|" $0 " -> " remote "/" $0
                    }
                  }
                }' ~/filtered_changes.tmp >> ~/files_to_upload

              # Process deletions
              git diff-tree --diff-filter=D --name-only -t "$git_previous_commit"..${{ github.sha }} -- "$local_path" > ~/deletions.tmp
              awk -v remote="$remote_path" -v flat="${flatten_flags[$local_path]}" '{
                if (flat == 1) {
                  split($0, parts, "/")
                  print remote "/" parts[length(parts)]
                } else {
                  print remote "/" $0
                }
              }' ~/deletions.tmp >> ~/files_to_delete

              rm -f ~/main_changes.tmp ~/filtered_changes.tmp ~/deletions.tmp
            done

            # Add override changes
            if [ -s ~/override_changes ]; then
              while read -r override_file; do
                rel_path="${override_file#${{ inputs.override-path }}/}"
                for local_path in "${!path_mappings[@]}"; do
                  if [[ "$rel_path" == "$local_path"* ]]; then
                    remote_path="${path_mappings[$local_path]}"
                    echo "${{ inputs.override-path }}|$rel_path -> $remote_path/${rel_path#$local_path/}" >> ~/files_to_upload
                    break
                  fi
                done
              done < ~/override_changes
            fi
          fi
        fi

        # Remove duplicates
        sort -u ~/files_to_upload -o ~/files_to_upload
        sort -u ~/files_to_delete -o ~/files_to_delete

        # Debug output
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "::group::File Changes"
          echo "Files to upload:"
          [ -s ~/files_to_upload ] && cat ~/files_to_upload || echo "None"
          show_hr
          echo "Files to delete:"
          [ -s ~/files_to_delete ] && cat ~/files_to_delete || echo "None"
          show_hr
          echo "Override changes:"
          [ -s ~/override_changes ] && cat ~/override_changes || echo "None"
          echo "::endgroup::"
        fi
        echo "::endgroup::"

        # File transfer
        echo "::group::Transfer files"
        function process_upload() {
          local src="$1"
          local dest="$2"
          local flatten="$3"

          # Get absolute source path from repository root
          local abs_src="$GITHUB_WORKSPACE/$src"

          if [ "$flatten" -eq 1 ]; then
            remote_file="$(basename "$src")"
            echo "FLAT UPLOAD: $abs_src → $dest/$remote_file"
            lftp -u "${{ inputs.remote-user }}","${{ inputs.remote-password }}" \
              -p "${{ inputs.remote-port }}" \
              -e "mkdir -p \"$dest\"; put -O \"$dest\" \"$abs_src\" -o \"$remote_file\"; quit" \
              "${{ inputs.remote-protocol }}://${{ inputs.remote-host }}"
          else
            relative_path="${src#$local_path/}"
            echo "NORMAL UPLOAD: $abs_src → $dest/$relative_path"
            lftp -u "${{ inputs.remote-user }}","${{ inputs.remote-password }}" \
              -p "${{ inputs.remote-port }}" \
              -e "mkdir -p \"$dest/$(dirname "$relative_path")\"; put -O \"$dest/$(dirname "$relative_path")\" \"$abs_src\" -o \"$(basename "$relative_path")\"; quit" \
              "${{ inputs.remote-protocol }}://${{ inputs.remote-host }}"
          fi
        }

        # Process uploads
        if [ -s ~/files_to_upload ]; then
          while IFS=" -> " read -r src dest; do
            local_path="${src%|*}"
            src_file="${src#*|}"
            # Construct full source path correctly
            if [[ "$local_path" == *"modified"* ]] || [[ "$local_path" == *"rmplugins"* ]] || [[ "$local_path" == *"szplugins"* ]]; then
              full_src_path="$local_path/$src_file"
            else
              full_src_path="$local_path/$src_file"
            fi
            # Verify file exists before uploading
            if [ -f "$GITHUB_WORKSPACE/$full_src_path" ]; then
              process_upload "$full_src_path" "$dest" "${flatten_flags[$local_path]}"
            else
              echo "::warning::File not found: $full_src_path"
            fi
          done < ~/files_to_upload
        else
          echo "No files to upload"
        fi

        # Process deletions
        if [ -s ~/files_to_delete ]; then
          echo "Deleting files:"
          lftp -u "${{ inputs.remote-user }}","${{ inputs.remote-password }}" \
            -p "${{ inputs.remote-port }}" \
            -e "rm -f $(awk '{printf "\"%s\" ", $0}' ~/files_to_delete); quit" \
            "${{ inputs.remote-protocol }}://${{ inputs.remote-host }}"
        else
          echo "No files to delete"
        fi
        echo "::endgroup::"

        # Cleanup
        echo "::group::Cleanup"
        rm -f ~/.netrc ~/files_to_upload ~/files_to_delete ~/override_changes
        echo "::endgroup::"
