name: "SFTP File Deployer"
description: "Advanced deployment with override support and flexible path mapping"

branding:
  icon: "upload"  
  color: "black"

inputs:
  host:
    description: "Remote host"
    required: true
  port:
    description: "Remote port"
    required: true
    default: 22
  user:
    description: "Username"
    required: true
  password:
    description: "Password"
    required: false
    default: ""
  paths:
    description: "Path mappings in JSON format (add :flat suffix to flatten)"
    required: true
    default: '{".": "."}'
  override-path:
    description: "Path to server-specific override folder"
    required: false
    default: ""
  excludes:
    description: "Files to exclude from sync"
    required: false
  debug:
    description: "Enable debug information (true, false)"
    required: false

runs:
  using: "composite"
  steps:
    - name: "Install dependencies"
      shell: bash
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y --no-install-recommends lftp jq

    - name: "Deploy"
      shell: bash
      run: |
        # Helper functions
        function show_hr() {
          printf '%.s_' {1..100} && echo ""
        }

        # Initialize
        echo "::group::Initialization"

        # Validate Git repo
        if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != "true" ]; then
          echo "::error::Git repository not found"
          exit 1
        fi

        # Parse path mappings
        declare -A path_mappings
        declare -A flatten_flags
        FLATTEN_KEYWORD=":flat"

        while IFS="=" read -r local_path remote_mapping; do
          if [[ "$remote_mapping" == *"$FLATTEN_KEYWORD"* ]]; then
            remote_path="${remote_mapping%$FLATTEN_KEYWORD}"
            flatten_flags["$local_path"]=1
          else
            remote_path="$remote_mapping"
            flatten_flags["$local_path"]=0
          fi
          path_mappings["$(echo "$local_path" | sed 's:/*$::')"]="$(echo "$remote_path" | sed 's:/*$::')"
        done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' <<< "${{ inputs.paths }}")

        # Debug output
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "Path Mappings:"
          for path in "${!path_mappings[@]}"; do
            echo "  $path → ${path_mappings[$path]} $([ ${flatten_flags[$path]} -eq 1 ] && echo "(FLAT)")"
          done
          show_hr
        fi

        # Setup configurations
        echo "::group::Configuration"
        mkdir -p ~/.ssh
        echo -e "StrictHostKeyChecking no\nUserKnownHostsFile /dev/null" > ~/.ssh/config
        chmod 600 ~/.ssh/config

        # Create lftp config
        cat > ~/.lftprc << 'EOF'
        set sftp:auto-confirm true
        set net:timeout 10
        set xfer:parallel 3
        set mirror:parallel-transfer-count 3
        EOF
        echo "::endgroup::"

        # File processing (always delta sync)
        echo "::group::Prepare files"
        touch ~/files_to_upload ~/files_to_delete ~/override_changes
        git_previous_commit=$(git rev-parse ${{ github.sha }}^)

        if git cat-file -t "$git_previous_commit" &>/dev/null; then
          # Process override folder if specified
          if [ -n "${{ inputs.override-path }}" ] && [ -d "${{ inputs.override-path }}" ]; then
            git diff --diff-filter=ACMRT --name-only "$git_previous_commit"..${{ github.sha }} -- "${{ inputs.override-path }}" > ~/override_changes
          fi

          # Process each path mapping
          for local_path in "${!path_mappings[@]}"; do
            remote_path="${path_mappings[$local_path]}"
            
            # Get changes from main folder (excluding overrides)
            git diff --diff-filter=ACMRT --name-only "$git_previous_commit"..${{ github.sha }} -- "$local_path" > ~/main_changes.tmp
            
            # Filter out overrides if they exist
            if [ -s ~/override_changes ]; then
              grep -vFf <(sed "s|^${{ inputs.override-path }}/||" ~/override_changes) ~/main_changes.tmp > ~/filtered_changes.tmp
            else
              cp ~/main_changes.tmp ~/filtered_changes.tmp
            fi

            # Apply excludes if specified
            if [ -n "${{ inputs.excludes }}" ]; then
              grep -vFf <(echo "${{ inputs.excludes }}" | tr ',' '\n') ~/filtered_changes.tmp > ~/filtered_changes2.tmp
              mv ~/filtered_changes2.tmp ~/filtered_changes.tmp
            fi

            # Convert to mapping format with proper flat handling
            awk -v local="$local_path" -v remote="$remote_path" -v flat="${flatten_flags[$local_path]}" '
              {
                  gsub("^" local "/?", "")
                  if ($0 != "") {
                    if (flat == 1) {
                        split($0, parts, "/")
                        print local "/" $0 "\t" remote "/" parts[length(parts)]
                    } else if (!match($0, /^(modified|rmplugins|szplugins)\//)) {
                        print local "/" $0 "\t" remote "/" $0
                    }
                  }
              }' ~/filtered_changes.tmp >> ~/files_to_upload

            # Process deletions
            git diff-tree --diff-filter=D --name-only -t "$git_previous_commit"..${{ github.sha }} -- "$local_path" > ~/deletions.tmp
            awk -v remote="$remote_path" -v flat="${flatten_flags[$local_path]}" '{
              if (flat == 1) {
                split($0, parts, "/")
                print remote "/" parts[length(parts)]
              } else {
                print remote "/" $0
              }
            }' ~/deletions.tmp >> ~/files_to_delete

            rm -f ~/main_changes.tmp ~/filtered_changes.tmp ~/deletions.tmp
          done

          # Add override changes
          if [ -s ~/override_changes ]; then
            while read -r override_file; do
              rel_path="${override_file#${{ inputs.override-path }}/}"
              for local_path in "${!path_mappings[@]}"; do
                if [[ "$rel_path" == "$local_path"* ]]; then
                  remote_path="${path_mappings[$local_path]}"
                  echo "${{ inputs.override-path }}|$rel_path -> $remote_path/${rel_path#$local_path/}" >> ~/files_to_upload
                  break
                fi
              done
            done < ~/override_changes
          fi
        fi

        # Remove duplicates
        sort -u ~/files_to_upload -o ~/files_to_upload
        sort -u ~/files_to_delete -o ~/files_to_delete

        # Debug output
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "::group::File Changes"
          echo "Files to upload:"
          [ -s ~/files_to_upload ] && cat ~/files_to_upload || echo "None"
          show_hr
          echo "Files to delete:"
          [ -s ~/files_to_delete ] && cat ~/files_to_delete || echo "None"
          show_hr
          echo "Override changes:"
          [ -s ~/override_changes ] && cat ~/override_changes || echo "None"
          echo "::endgroup::"
        fi
        echo "::endgroup::"

        # File transfer
        echo "::group::Transfer files"
        function process_upload() {
            local src="$1"
            local dest="$2"
            
            # Create secure LFTP script file
            cat > ~/lftp_commands <<'LFTP_SCRIPT'
            set cmd:fail-exit true
            mkdir -p "${dest%/*}"
            put "$GITHUB_WORKSPACE/$src" -o "$dest"
            quit LFTP_SCRIPT
            
            echo "UPLOAD: $src → $dest"
            lftp -u "${{ inputs.user }}","${{ inputs.password }}" \
                -p "${{ inputs.port }}" \
                -f ~/lftp_commands \
                "sftp://${{ inputs.host }}"
            rm -f ~/lftp_commands
        }

        # Process uploads
        if [ -s ~/files_to_upload ]; then
            while IFS=$'\t' read -r src dest; do
                if [ -f "$GITHUB_WORKSPACE/$src" ]; then
                    process_upload "$src" "$dest"
                else
                    echo "::warning::File not found: $src"
                fi
            done < ~/files_to_upload
        else
            echo "No files to upload"
        fi
        echo "::endgroup::"

        # Process deletions
        if [ -s ~/files_to_delete ]; then
          echo "Deleting files:"
          lftp -u "${{ inputs.user }}","${{ inputs.password }}" \
            -p "${{ inputs.port }}" \
            -e "rm -f $(awk '{printf "\"%s\" ", $0}' ~/files_to_delete); quit" \
            "sftp://${{ inputs.host }}"
        else
          echo "No files to delete"
        fi
        echo "::endgroup::"

        # Cleanup
        echo "::group::Cleanup"
        rm -f ~/.netrc ~/files_to_upload ~/files_to_delete ~/override_changes
        echo "::endgroup::"
