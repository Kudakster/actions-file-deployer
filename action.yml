name: "SFTP File Deployer"
description: "Fast delta-sync deployment with parallel connections"

branding:
  icon: "upload"  
  color: "black"

inputs:
  host:
    description: "Remote host"
    required: true
  port:
    description: "Remote port"
    required: true
    default: 22
  user:
    description: "SSH username"
    required: true
  password:
    description: "SSH password"
    required: false
    default: ""
  paths:
    description: "Path mappings in JSON format (add :flat suffix to flatten)"
    required: true
    default: '{".": "."}'
  excludes:
    description: "Files to exclude from sync"
    required: false
  debug:
    description: "Enable debug information (true, false)"
    required: false

runs:
  using: "composite"
  steps:
    - name: "Install dependencies"
      shell: bash
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y --no-install-recommends lftp jq

    - name: "Deploy"
      shell: bash
      run: |
        # Helper functions
        function show_hr() {
          printf '%.s_' {1..100} && echo ""
        }

        # Initialize
        echo "::group::Initialization"

        # Validate Git repo
        if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != "true" ]; then
          echo "::error::Git repository not found"
          exit 1
        fi

        # Parse path mappings
        declare -A path_mappings
        declare -A flatten_flags
        FLATTEN_KEYWORD=":flat"

        while IFS="=" read -r local_path remote_mapping; do
          if [[ "$remote_mapping" == *"$FLATTEN_KEYWORD"* ]]; then
            remote_path="${remote_mapping%$FLATTEN_KEYWORD}"
            flatten_flags["$local_path"]=1
          else
            remote_path="$remote_mapping"
            flatten_flags["$local_path"]=0
          fi
          path_mappings["$(echo "$local_path" | sed 's:/*$::')"]="$(echo "$remote_path" | sed 's:/*$::')"
        done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' <<< "${{ inputs.paths }}")

        # Debug output
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "Path Mappings:"
          for path in "${!path_mappings[@]}"; do
            echo "  $path → ${path_mappings[$path]} $([ ${flatten_flags[$path]} -eq 1 ] && echo "(FLAT)")"
          done
          show_hr
        fi

        # Setup configurations
        echo "::group::Configuration"
        mkdir -p ~/.ssh
        echo -e "StrictHostKeyChecking no\nUserKnownHostsFile /dev/null" > ~/.ssh/config
        chmod 600 ~/.ssh/config

        # Create lftp config
        cat > ~/.lftprc << 'EOF'
        set sftp:auto-confirm true
        set net:timeout 10
        set xfer:parallel 3
        set mirror:parallel-transfer-count 3
        EOF
        echo "::endgroup::"

        # File processing (delta sync only)
        echo "::group::Prepare files"
        touch ~/files_to_upload ~/files_to_delete ~/override_changes
        git_previous_commit=$(git rev-parse ${{ github.sha }}^)

        if git cat-file -t "$git_previous_commit" &>/dev/null; then
          # Process each path mapping
          for local_path in "${!path_mappings[@]}"; do
            remote_path="${path_mappings[$local_path]}"
            
            # Get changes from main folder
            git diff --diff-filter=ACMRT --name-only "$git_previous_commit"..${{ github.sha }} -- "$local_path" > ~/main_changes.tmp
            
            # Apply excludes if specified
            if [ -n "${{ inputs.excludes }}" ]; then
              grep -vFf <(echo "${{ inputs.excludes }}" | tr ',' '\n') ~/main_changes.tmp > ~/filtered_changes.tmp
              mv ~/filtered_changes.tmp ~/main_changes.tmp
            fi

            # Convert to mapping format with proper flat handling
            awk -v local="$local_path" -v remote="$remote_path" -v flat="${flatten_flags[$local_path]}" '
              {
                  gsub("^" local "/?", "")
                  if ($0 != "") {
                    if (flat == 1) {
                        split($0, parts, "/")
                        print local "/" $0 "\t" remote "/" parts[length(parts)]
                    } else {
                        print local "/" $0 "\t" remote "/" $0
                    }
                  }
              }' ~/main_changes.tmp >> ~/files_to_upload

            # Process deletions
            git diff-tree --diff-filter=D --name-only -t "$git_previous_commit"..${{ github.sha }} -- "$local_path" > ~/deletions.tmp
            awk -v remote="$remote_path" -v flat="${flatten_flags[$local_path]}" '{
              if (flat == 1) {
                split($0, parts, "/")
                print remote "/" parts[length(parts)]
              } else {
                print remote "/" $0
              }
            }' ~/deletions.tmp >> ~/files_to_delete

            rm -f ~/main_changes.tmp ~/deletions.tmp
          done
        fi

        # Remove duplicates
        sort -u ~/files_to_upload -o ~/files_to_upload
        sort -u ~/files_to_delete -o ~/files_to_delete

        # Debug output
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "::group::File Changes"
          echo "Files to upload:"
          [ -s ~/files_to_upload ] && cat ~/files_to_upload || echo "None"
          show_hr
          echo "Files to delete:"
          [ -s ~/files_to_delete ] && cat ~/files_to_delete || echo "None"
          echo "::endgroup::"
        fi
        echo "::endgroup::"

        # File transfer using improved delta sync method
        echo "::group::Transfer files"
        
        # Create marker file
        touch ~/.deploy-running
        
        function process_upload_batch() {
          local local_base="$1"
          local remote_base="$2"
          
          # Create LFTP script for batch upload
          cat > ~/lftp_upload_script <<EOF
        set xfer:log true
        set cmd:fail-exit true
        lcd "$local_base"
        put -O "$remote_base" ~/.deploy-running
        mput -d -O "$remote_base" $(awk '{ printf "\"%s\" ", $1 }' ~/files_to_upload)
        rm -f "$remote_base/.deploy-running"
        quit
        EOF
          
          lftp -u "${{ inputs.user }}","${{ inputs.password }}" \
            -p "${{ inputs.port }}" \
            -f ~/lftp_upload_script \
            "sftp://${{ inputs.host }}"
            
          rm -f ~/lftp_upload_script
        }

        # Process deletions
        if [ -s ~/files_to_delete ]; then
          echo "Deleting files:"
          lftp -u "${{ inputs.user }}","${{ inputs.password }}" \
            -p "${{ inputs.port }}" \
            -e "rm -f $(awk '{printf "\"%s\" ", $0}' ~/files_to_delete); quit" \
            "sftp://${{ inputs.host }}"
        fi

        # Process uploads in batches per path mapping
        for local_path in "${!path_mappings[@]}"; do
          remote_path="${path_mappings[$local_path]}"
          awk -v local="$local_path" '$1 ~ "^" local "/" {print $0}' ~/files_to_upload > ~/current_batch.txt
          
          if [ -s ~/current_batch.txt ]; then
            echo "Processing batch for: $local_path → $remote_path"
            process_upload_batch "$local_path" "$remote_path"
          fi
          
          rm -f ~/current_batch.txt
        done

        rm -f ~/.deploy-running
        echo "::endgroup::"

        # Cleanup
        echo "::group::Cleanup"
        rm -f ~/.netrc ~/files_to_upload ~/files_to_delete ~/override_changes
        echo "::endgroup::"
